# Guide d√©taill√© du fichier `docker-compose.yml`

> **Rappel** : avec Docker Desktop/Compose V2, la commande est `docker compose ‚Ä¶` (sans tiret). Les sp√©cifications ci‚Äëdessous suivent la grammaire "Compose Specification" (ex‚ÄëV3).

---

## Squelette minimal et principes YAML

```yaml
# docker-compose.yml ‚Äî squelette minimal
services:
  app:
    image: busybox:stable
    command: ["sh", "-c", "echo Hello && sleep 3600"]
```

* **YAML** : sensible aux indentations **espaces** (pas de tabulations), couples cl√©: valeur.
* Les **listes** se notent avec `- item` ou sous forme **JSON inline** `[a, b]`.
* Les **cha√Ænes** peuvent √™tre brutes (`valeur`), entre guillemets (`"valeur"`), ou multilignes (`|`).

---

## 2) Cl√©s de haut niveau

| Cl√©                   | R√¥le                                                              |
|-----------------------|-------------------------------------------------------------------|
| `services`            | D√©clare chaque conteneur de l‚Äôapplication. **Obligatoire.**       |
| `volumes`             | (Optionnel) D√©clare des **volumes nomm√©s** r√©utilisables.         |
| `networks`            | (Optionnel) D√©clare des **r√©seaux** personnalis√©s.                |
| `secrets` / `configs` | (Optionnel) Gestion de secrets/config (compat. Swarm et Compose). |

> Compose V2 n‚Äôimpose plus `version:` (ex: `3.9`).

---

## Service : options les plus courantes

### `image`, `build`, `container_name`, `restart`

```yaml
services:
  web:
    image: nginx:1.27-alpine         # prend l‚Äôimage publique
    container_name: demo-nginx       # nom lisible (sinon g√©n√©r√©)
    restart: unless-stopped          # red√©marrage automatique

  api:
    build:
      context: ./api                 # dossier contenant le Dockerfile
      dockerfile: Dockerfile.prod    # nom alternatif
      target: runtime                # stage cible (multi-stage)
      args:                          # ARG envoy√©s au build
        APP_ENV: production
```

**Notes** :

* `restart`: valeurs utiles ‚Äî `no` (d√©faut), `on-failure`, `always`, `unless-stopped`.
* `build` et `image` peuvent coexister (l‚Äôimage r√©sultante est tagu√©e automatiquement `project_service`), mais on pr√©f√®re **l‚Äôun ou l‚Äôautre**.

### R√©seau & ports : `ports`, `expose`, `networks`

```yaml
services:
  web:
    image: nginx:alpine
    ports:            # mappage h√¥te:conteneur
      - "8080:80"      # TCP par d√©faut
      - "127.0.0.1:8443:443" # bind sur loopback seulement
    expose:
      - "8081"         # visible par les autres services, pas par l‚Äôh√¥te
    networks:
      - frontnet
      - backnet

networks:
  frontnet: {}
  backnet:  {}
```

#### Comprendre les **ports**

Les **ports** permettent d‚Äôexposer un service Docker vers l‚Äôext√©rieur ou d‚Äôautoriser la communication entre conteneurs.

##### Exemple simple :

```yaml
services:
  web:
    image: nginx
    ports:
      - "8080:80"   # <port_local>:<port_conteneur>
```

Ici, le port **80** √† l‚Äôint√©rieur du conteneur (celui de Nginx) est accessible via le port **8080** de l‚Äôh√¥te. Vous pouvez donc visiter [http://localhost:8080](http://localhost:8080) pour voir votre serveur web.

##### Ports multiples et adresses sp√©cifiques

```yaml
ports:
  - "8080:80"             # accessible sur toutes les interfaces
  - "127.0.0.1:9090:90"   # accessible seulement en local (loopback)
  - "443:443/tcp"         # protocole sp√©cifi√©
```

##### Exposer un port sans le rendre public

```yaml
expose:
  - "3306"
```

`expose` rend le port visible uniquement **entre conteneurs du m√™me r√©seau** Docker, mais pas depuis l‚Äôh√¥te. C‚Äôest utile pour les bases de donn√©es, par exemple.

##### Cas pratique :

```yaml
services:
  db:
    image: mariadb
    expose:
      - "3306"
  web:
    image: php:apache
    ports:
      - "8080:80"
    depends_on:
      - db
```

Le conteneur `web` pourra acc√©der √† la base `db` via le port **3306**, m√™me si ce port n‚Äôest pas expos√© √† l‚Äôext√©rieur.

> üí° **Conseil :** √©vitez d‚Äôexposer inutilement des ports sensibles (comme 3306, 6379 ou 27017). Utilisez `expose` √† la place lorsque possible.

---

### Variables : `environment`, `env_file`, substitution `.env`

```yaml
services:
  app:
    image: node:20-alpine
    environment:
      NODE_ENV: ${NODE_ENV:-development}  # d√©faut si non d√©fini
      API_URL: http://api:8080
    env_file:                             # charge depuis un fichier
      - ./.env
```

* Fichier `.env` (au m√™me niveau que `docker-compose.yml`) permet d‚Äôinjecter des variables :

  ```dotenv
  NODE_ENV=production
  SECRET_TOKEN=s3cr3t
  ```
* Priorit√© : `environment` inline > `env_file` > `.env` du projet.

### Volumes : bind‚Äëmount, nomm√©s, `tmpfs`

```yaml
services:
  db:
    image: mariadb:11
    environment:
      MYSQL_ROOT_PASSWORD: exemple
    volumes:
      - dbdata:/var/lib/mysql           # volume **nomm√©** (persistant)
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql:ro  # bind ro
      - type: tmpfs                     # donn√©es √©ph√©m√®res en RAM
        target: /tmp

volumes:
  dbdata: {}  # d√©fini au niveau racine
```

#### Comprendre les **volumes**

Les **volumes** permettent de **conserver les donn√©es** m√™me apr√®s la suppression des conteneurs. Ils peuvent aussi **lier** des dossiers de votre machine h√¥te √† ceux des conteneurs.

##### Trois types de volumes

| Type             | Description                                      | Exemple                        |
|------------------|--------------------------------------------------|--------------------------------|
| **Volume nomm√©** | G√©r√© par Docker, persistant entre red√©ploiements | `dbdata:/var/lib/mysql`        |
| **Bind mount**   | Monte un dossier local sp√©cifique                | `./site:/usr/share/nginx/html` |
| **Tmpfs**        | Stocke des donn√©es temporaires en m√©moire        | `type: tmpfs`                  |

##### Exemple pratique

```yaml
services:
  web:
    image: nginx
    volumes:
      - ./site:/usr/share/nginx/html   # bind : dossier du projet ‚Üí conteneur
  db:
    image: mariadb
    environment:
      MYSQL_ROOT_PASSWORD: secret
    volumes:
      - dbdata:/var/lib/mysql          # volume nomm√©

volumes:
  dbdata: {}
```

* Le dossier local `./site` est mont√© dans le conteneur `web`, ce qui permet d‚Äô√©diter les fichiers en direct.
* Le volume `dbdata` conserve les donn√©es de la base MariaDB m√™me si le conteneur `db` est supprim√©.

##### Volumes en lecture seule et multiples

```yaml
volumes:
  - ./config:/etc/nginx/conf.d:ro    # lecture seule
  - ./logs:/var/log/nginx            # un autre dossier mont√©
```

Le suffixe `:ro` rend le volume **read-only**. Tr√®s utile pour √©viter qu‚Äôun service modifie des fichiers de configuration.

##### Volume tmpfs (RAM)

```yaml
volumes:
  - type: tmpfs
    target: /tmp/cache
```

Les donn√©es de `/tmp/cache` seront stock√©es en m√©moire vive et dispara√Ætront √† l‚Äôarr√™t du conteneur.

##### Inspection et suppression

```bash
# Voir les volumes existants
docker volume ls

# Inspecter un volume
docker volume inspect dbdata

# Supprimer un volume inutilis√©
docker volume prune
```

> üí° **Conseil :** pr√©f√©rez les volumes nomm√©s pour les donn√©es de base de donn√©es ou persistantes, et les bind mounts pour le d√©veloppement (√©dition directe des fichiers du projet).

---

### D√©marrage ordonn√© : `depends_on` + `healthcheck`

```yaml
services:
  db:
    image: postgres:16
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 3s
      retries: 10

  api:
    image: myorg/api:latest
    depends_on:
      db:
        condition: service_healthy     # attend la sant√© OK
```

> `depends_on.condition` fonctionne avec les **healthchecks**.

### Commande, entr√©e, utilisateur, dossier de travail

```yaml
services:
  worker:
    image: python:3.12-alpine
    working_dir: /app
    user: "1000:1000"                    # uid:gid
    volumes:
      - ./worker:/app
    entrypoint: ["python", "-m", "worker"] # remplace ENTRYPOINT
    command: ["--queue", "emails"]          # remplace CMD
```

### Limites et capacit√©s : `deploy.resources` (locale) et `ulimits`

> En local (non‚ÄëSwarm), `deploy` est **partiellement** support√© par certains runtimes ; pour Compose, privil√©giez `cpus`, `mem_limit` et `ulimits` au niveau service.

```yaml
services:
  cpu_job:
    image: busybox
    command: ["sh", "-c", "yes > /dev/null"]
    cpus: 1.5           # ‚âà quotas CPU (Compose V2)
    mem_limit: 512m     # limite m√©moire
    ulimits:
      nofile: 65535
```

### Logs, red√©marrage, arr√™t propre

```yaml
services:
  app:
    image: golang:1.22-alpine
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"
    stop_signal: SIGINT
    stop_grace_period: 15s
```
---

## Exemples multilayers pr√™ts √† copier

### LAMP minimal (Apache + PHP + MariaDB)

```yaml
services:
  web:
    image: php:8.3-apache
    ports: ["8080:80"]
    volumes:
      - ./www:/var/www/html
    depends_on:
      db:
        condition: service_started

  db:
    image: mariadb:11
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: app
      MYSQL_USER: app
      MYSQL_PASSWORD: app
    volumes:
      - dbdata:/var/lib/mysql

volumes:
  dbdata: {}
```

### Nginx en reverse‚Äëproxy + deux backends

```yaml
services:
  reverse:
    image: nginx:alpine
    ports: ["80:80"]
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - api
      - frontend

  api:
    image: myorg/api:latest
    environment:
      DB_URL: postgres://postgres:postgres@db:5432/app

  frontend:
    image: node:20-alpine
    command: ["sh", "-c", "npm ci && npm run start"]
    working_dir: /app
    volumes: ["./frontend:/app"]

  db:
    image: postgres:16
    environment:
      POSTGRES_PASSWORD: postgres

networks:
  default:
    name: appnet  # r√©seau unique commun aux services
```

### Profiles (dev vs prod) + overrides

```yaml
# docker-compose.yml (base)
services:
  api:
    build: { context: ./api }
    environment:
      LOG_LEVEL: info
    ports: ["8080:8080"]

---
# docker-compose.dev.yml
services:
  api:
    profiles: [dev]
    environment:
      LOG_LEVEL: debug
    volumes:
      - ./api:/app

---
# Commandes
# Dev :
#   docker compose -f docker-compose.yml -f docker-compose.dev.yml --profile dev up -d
# Prod (base seule) :
#   docker compose up -d
```

### Secrets & configs (fichiers sensibles)

```yaml
services:
  app:
    image: nginx:alpine
    secrets:
      - api_key
    configs:
      - site_conf

secrets:
  api_key:
    file: ./secrets/api_key.txt

configs:
  site_conf:
    file: ./nginx/site.conf
```

### Attendre la BD proprement (healthcheck + wait‚Äëfor)

```yaml
services:
  db:
    image: postgres:16
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      retries: 12

  migrator:
    image: flyway/flyway:10
    depends_on:
      db:
        condition: service_healthy
    command: -url=jdbc:postgresql://db:5432/postgres -user=postgres -password=postgres migrate
```

### Multi‚Äër√©seaux (front/back isolation)

```yaml
services:
  web:
    image: nginx:alpine
    ports: ["8080:80"]
    networks: [front]

  api:
    image: myorg/api
    networks: [front, back]

  db:
    image: postgres:16
    networks: [back]

networks:
  front: {}
  back: {}
```

---

## Fichiers, structure et workflow

```
project/
‚îú‚îÄ docker-compose.yml
‚îú‚îÄ docker-compose.dev.yml        # overrides (optionnel)
‚îú‚îÄ .env                          # variables du projet
‚îú‚îÄ secrets/                      # fichiers sensibles (git‚Äëignored)
‚îú‚îÄ www/                          # sources web
‚îî‚îÄ db_data/                      # volume bind local (dev)
```

**Cycle de vie type**

```bash
# D√©marrer en arri√®re-plan
docker compose up -d

# Voir les conteneurs et leur √©tat
docker compose ps

# Logs (stream)
docker compose logs -f api

# Ex√©cuter une commande dans un conteneur
docker compose exec api sh

# Appliquer des changements d‚Äôimage
docker compose up -d --build api

# Arr√™ter + supprimer conteneurs/r√©seaux (pr√©serve volumes)
docker compose down

# Tout supprimer, y compris volumes nomm√©s
docker compose down -v
```

---

## S√©curit√© & bonnes pratiques

* **Ne commitez pas** de secrets en clair : utilisez `secrets`, variables d‚Äôenvironnement hors VCS, coffre de secrets.
* Pr√©f√©rez des **images officielles, tagu√©es** (`x.y` ou `x.y-alpine`) plut√¥t que `latest`.
* Ajoutez des **healthchecks** aux services critiques.
* Limitez les droits : `user:`, `read_only: true`, `cap_drop: [ALL]` puis `cap_add` au cas par cas.
* Surveillez les logs et **limitez leur taille** (`logging.options.max-size`).

---

## D√©pannage rapide (FAQ)

* **Port d√©j√† utilis√©** : changez la partie **h√¥te** dans `ports` (`8081:80`).
* **Variables non prises en compte** : v√©rifiez `.env`, l‚Äôordre des `-f` et la **priorit√©** (inline > env_file > .env).
* **BD non pr√™te** : utilisez `healthcheck` + `depends_on.condition: service_healthy`.
* **Volumes qui ne persistent pas** : utilisez des **volumes nomm√©s** au lieu de bind sur `/tmp`.
* **Diff√©rences Swarm/Compose** : √©vitez `deploy:` en local ; pr√©f√©rez `cpus`, `mem_limit`.

---

## Exemple ¬´ tout‚Äëen‚Äëun ¬ª

```yaml
# Exemple complet pour une appli web avec cache et migrations
services:
  web:
    image: nginx:1.27-alpine
    ports: ["80:80"]
    volumes:
      - ./deploy/nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      api:
        condition: service_started
    networks: [front]

  api:
    build:
      context: ./api
      target: runtime
      args: { APP_ENV: production }
    environment:
      DB_URL: postgresql://postgres:postgres@db:5432/app
      REDIS_URL: redis://cache:6379
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 10s
      timeout: 3s
      retries: 5
    networks: [front, back]

  cache:
    image: redis:7-alpine
    command: ["redis-server", "--appendonly", "yes"]
    volumes: ["cachedata:/data"]
    networks: [back]

  db:
    image: postgres:16
    environment:
      POSTGRES_PASSWORD: postgres
    volumes:
      - dbdata:/var/lib/postgresql/data
    networks: [back]

  migrator:
    image: flyway/flyway:10
    depends_on:
      db:
        condition: service_healthy
    command: -url=jdbc:postgresql://db:5432/postgres -user=postgres -password=postgres migrate
    networks: [back]

volumes:
  dbdata: {}
  cachedata: {}

networks:
  front: {}
  back: {}
```
---